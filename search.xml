<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>second assignment of probability theory</title>
      <link href="/2020/03/24/second-assignment-of-probability-theory/"/>
      <url>/2020/03/24/second-assignment-of-probability-theory/</url>
      
        <content type="html"><![CDATA[<ol><li><p>第一章习题14（p50）</p><p>解：</p><p>a.$\frac{1}{6}$</p><p>b. there are six kinds of situations，two of them are pairs, so the probability is $\frac{1}{3}$</p><p>c.$\frac{11}{36}$</p><p>d.$\frac{1}{3}$</p></li></ol><ol start="2"><li><p>第一章习题16（p50）</p><p>解：</p><p>$\frac{1}{2}$</p></li><li><p>第一章习题18（p50）</p><p>证明：using the definition of conditional probability :</p><p>$P(A\cap B|B)= P(A\cap B\cap B)/P(B)=P(A\cap B)/P(B)=P(A|B)$</p></li></ol><ol start="4"><li><p>第一章习题20（p51）</p><p>a. 解：</p><p>1.$p^2_w+2p_w(1-p_w)p_w=3p^2_w-2p^3_w$</p><p>2.$p^2_d\cdot p_w$</p><p>3.$p_w\cdot p_d+p_w\cdot (1-p_d)\cdot p_w+(1-p_w)\cdot p_w\cdot p_w$</p><p>b. 证明：</p><p>When $p_w$is lower than 0.5,  but $p_d$ is greater than 0.5, the player can choose the defensive mode to increase the winning probability.</p><p>For example: $p_w=0.45,p_d=0.9$</p><p>the winning probability will be $p_w\cdot p_d+p_w\cdot (1-p_d)\cdot p_w+(1-p_w)p_w^2=0.45\cdot 0.9+0.45\cdot 0.1\cdot 0.45+(1-0.45)\cdot 0.45^2$</p><p>$=0.405+0.02025+0.55\cdot0.2025=0.537$</p></li><li><p>第一章习题24（p51）</p><p>解：There are four possible outcomes:</p><p>   A and B are to be released, and guard says B        probability = $\frac{1}{3}$</p><p>   A and C are to be released, and guard says C        probability = $\frac{1}{3}$</p><p>   B and C are to be released, and guard says B        probability = $\frac{1}{6}$</p><p>   B and C are to be released, and guard says C        probability = $\frac{1}{6}$</p><p>   P(A is to be released|guard says B)=<br>$$<br>\frac{\frac{1}{3}}{\frac{1}{3}+\frac{1}{6}}=\frac{2}{3}<br>$$<br>   Similarly, P(A is to be released|guard says C)=$\frac{2}{3}$</p><p>   Thus, the probability that A is to be released will not change.</p></li><li><p>第一章习题25（p51）</p><p>解：</p><p>Let:</p><p>$$A=\{X&lt;\underline{m}), \quad B=\{\underline{m}&lt;X&lt;\bar{m}), \quad C=\{\bar{m}&lt;X)$$</p><p>A,B,C, refer to different cases.</p><p>$\underline{m}$ refers to the smaller amount, $\bar{m}$ refers to the larger amount.</p><p>$\mathbf{P}(W)$ refers to the possibility to have the larger amount.</p><p>$$\begin{array}{l}<br>\mathbf{P}(W | A)=\frac{1}{2}(\mathbf{P}(W | \bar{A})+\mathbf{P}(W | \underline{A}))=\frac{1}{2}(1+0)=\frac{1}{2} \\\<br>\mathbf{P}(W | B)=\frac{1}{2}(\mathbf{P}(W | \bar{B})+\mathbf{P}(W | \underline{B}))=\frac{1}{2}(1+1)=1 \\\<br>\mathbf{P}(W | C)=\frac{1}{2}(\mathbf{P}(W | \bar{C})+\mathbf{P}(W | \underline{C}))=\frac{1}{2}(0+1)=\frac{1}{2}<br>\end{array}$$</p><p>$$\begin{aligned}<br>\mathbf{P}(W) &amp;=\mathbf{P}(A) \mathbf{P}(W | A)+\mathbf{P}(B) \mathbf{P}(W | B)+\mathbf{P}(C) \mathbf{P}(W | C) \\\<br>&amp;=\frac{1}{2}(\mathbf{P}(A)+\mathbf{P}(B)+\mathbf{P}(C))+\frac{1}{2} \mathbf{P}(B) \\\<br>&amp;=\frac{1}{2}+\frac{1}{2} \mathbf{P}(B)<br>\end{aligned}$$</p><p>$\mathbf{P}(B)&gt;0$ as assumed. Thus, it follows that $\mathbf{P}(W)&gt;1/2$</p></li></ol><ol start="7"><li><p>第一章习题26（p52）</p><p>解：<br>$$<br>\mathbf{P}(A | B)=\frac{\mathbf{P}(A \cap B)}{\mathbf{P}(B)}=\frac{\mathbf{P}(A) \mathbf{P}(B | A)}{\mathbf{P}(B)}<br>$$<br> $\mathbf{P}(B)=1-q$ , as all the crows are black(hypothesis).</p><p> $\mathbf{P}(A)=p .$ </p><p> $\mathbf{P}(B | A)=1-q=\mathbf{P}(B),$ as the probability of observing a (black) crow is not affected by the truth of our hypothesis. </p><p>Therefore,  $\mathbf{P}(A | B)=\mathbf{P}(A)=p$. </p><p>Thus, the new evidence, while compatible with the hypothesis “all cows are white,” does not change our beliefs about its truth.<br>(b)<br>$$<br>\mathbf{P}(A | C)=\frac{\mathbf{P}(A \cap C)}{\mathbf{P}(C)}=\frac{\mathbf{P}(A) \mathbf{P}(C | A)}{\mathbf{P}(C)}<br>$$<br>Given the event $A$, a cow is observed with probability $q$, and it must be white. Thus, $\mathbf{P}(C | A)=q .$ Given the event $A^{c},$ a cow is observed with probability $q,$ and it is white with probability $1 / 2 .$ Thus, $\mathbf{P}\left(C | A^{c}\right)=q / 2 .$ Using the total probability theorem,<br>$$<br>\mathbf{P}(C)=\mathbf{P}(A) \mathbf{P}(C | A)+\mathbf{P}\left(A^{c}\right) \mathbf{P}\left(C | A^{c}\right)=p q+(1-p) \frac{q}{2}<br>$$<br>Hence,<br>$$<br>\mathbf{P}(A | C)=\frac{p q}{p q+(1-p) \frac{q}{2}}=\frac{2 p}{1+p}&gt;p<br>$$</p></li><li><p>第一章习题31（p53）</p><p>解：</p><p>(a) $A$ is the event that 0 is transmitted, the probability of correct transmission is :<br>$$<br>\mathbf{P}(A)\left(1-\epsilon_{0}\right)+(1-\mathbf{P}(A))\left(1-\epsilon_{1}\right)=p\left(1-\epsilon_{0}\right)+(1-p)\left(1-\epsilon_{1}\right)<br>$$<br>(b) The probability that 1011 is corrected transmitted is :<br>$$<br>\left(1-\epsilon_{0}\right)\left(1-\epsilon_{1}\right)^{3}<br>$$<br>(c) The string received must be 100, 000, 010, 001 to be correctly identified as 0.</p><p>While transmitting 000, the probability that received as 000 is $\left(1-\epsilon_{0}\right)^{3},$</p><p>as $001,010,$ $100$ $\epsilon_{0}\left(1-\epsilon_{0}\right)^{2}$ each.</p><p>Thus, the probability of correct transmission is<br>$$<br>3 \epsilon_{0}\left(1-\epsilon_{0}\right)^{2}+\left(1-\epsilon_{0}\right)^{3}<br>$$<br>(d) To improve the correctness of the transmission of 0, it has to be<br>$$<br>3 \epsilon_{0}\left(1-\epsilon_{0}\right)^{2}+\left(1-\epsilon_{0}\right)^{3}&gt;\left(1-\epsilon_{0}\right)<br>$$<br>or<br>$$<br>\left(1-\epsilon_{0}\right)\left(1+2 \epsilon_{0}\right)&gt;1<br>$$<br>which is equivalent to $0&lt;\epsilon_{0}&lt;1 / 2$<br>(e) Using Bayes’ rule, we have<br>$$<br>\mathbf{P}(0 | 101)=\frac{\mathbf{P}(0) \mathbf{P}(101 | 0)}{\mathbf{P}(0) \mathbf{P}(101 | 0)+\mathbf{P}(1) \mathbf{P}(101 | 1)}<br>$$<br>the probabilities needed in the equation are listed as follow.<br>$$<br>\mathbf{P}(0)=p, \quad \mathbf{P}(1)=1-p, \quad \mathbf{P}(101 | 0)=\epsilon_{0}^{2}\left(1-\epsilon_{0}\right), \quad \mathbf{P}(101 | 1)=\epsilon_{1}\left(1-\epsilon_{1}\right)^{2}<br>$$</p></li><li><p>第一章习题33（p54）</p><p>解：</p><p>As long as $\mathbf{P}$ (heads) $&gt;0$ and $\mathbf{P}(\text { tails })&gt;0$ , flipping the coin for twice, the probabilities of heads-tails, and tails-heads, are the same. So repeat the process of flipping twice until the decision has been made. Assuming $A_k$ is the probability that the decision has made in the $k^{th}$ round, then the conclusion is that<br>$$<br>P(\text { opera })=\sum_{k=1}^{\infty} P\left(\text { opera } | A_{k}\right) P\left(A_{k}\right)=\sum_{k=1}^{\infty} \frac{1}{2} P\left(A_{k}\right)=\frac{1}{2}<br>$$<br>$P\left(\text { opera } | A_{k}\right) $  is $\frac{1}{2}$ , and $\sum_{k=0}^{\infty} \mathbf{P}\left(A_{k}\right)=1$ , which are easy to infer.</p></li></ol><ol start="10"><li><p>第一章习题35（p54）</p><p>解：</p><p>$A_i$ is exactly the event that $i$ components are optional.<br>$$<br>\sum_{i=k}^{n} \mathbf{P}\left(A_{i}\right)=\sum_{i=k}^{n} p(i)<br>$$<br>where $p(i)$ are the binomial probabilities. Thus, the probability of an operational system is<br>$$<br>\sum_{i=k}^{n}\left(\begin{array}{l}<br>n \<br>i<br>\end{array}\right) p^{i}(1-p)^{n-i}<br>$$</p></li><li><p>自学：视频到L03-10。</p></li><li><p>自学：第一章习题49，50，52，55，57（p60）</p></li><li><p>(o) 思考题：请证明条件概率是一个概率律（满足概率三条公理）？</p><p>证明：</p><p>$(\mathrm{a}) 0 \leq P(E | F) \leq 1$<br>(b) $P(S | F)=1$<br>(c) $\overrightarrow{\mathrm{E} }_i(i=1,2, \cdots)$ 为互不相容的事件序列，则<br>$$<br>P\left(\bigcup_{i=1}^{\infty} E_{i} | F\right)=\sum_{i=1}^{\infty} P\left(E_{i} | F\right)<br>$$</p></li><li><p>(o) 思考题：请证明：$$P(\bigcap_{i=1}^nA_i)=P(A_1)P(A_2|A_1)P(A_3|A_1\cap A_2)\ldots P(A_n|\bigcap_{i=1}^{n-1}A_i)$$</p><p>证明：</p><p>$P(A_n|\bigcap_{i=1}^{n-1}A_i)\cdot P(\bigcap_{i=1}^{n-1}A_i)=P(\bigcap_{i=1}^{n}A_i)$</p><p>所以 $P(A_1)P(A_2|A_1)P(A_3|A_1\cap A_2)\ldots P(A_n|\bigcap_{i=1}^{n-1}A_i)\\\\=P(A_2\cap A_1)P(A_3|A_1\cap A_2)\ldots P(A_n|\bigcap_{i=1}^{n-1}A_i)\\\\=P(A_3\cap A_1\cap A_2)\ldots P(A_n|\bigcap_{i=1}^{n-1}A_i)\\\\\vdots\\\\=P(\bigcap_{i=1}^nA_i)$</p></li></ol><ol start="15"><li><p>(*) 思考题：两个相互独立的事件，是否一定条件独立？如果是，请证明；如果不是，请给出示例。<br>事件A是两次掷骰子的和为奇数，事件B是第一次掷骰子为奇数，条件C是掷两次骰子，第二次掷骰子为奇数。<br>$P(A)=\frac{1}{2}$，$P(B)=\frac{1}{2}$  $P(AB)=\frac{1}{4}$<br>$P(A|C)=\frac{1}{2}$，$P(B|C)=\frac{1}{2}$  $P(AB|C)=0$</p></li><li><p>(*) 思考题：两个在某个条件$C$下条件独立的事件，是否一定相互独立？如果是，请证明；如果不是，请给出示例。<br>有一枚硬币正面的概率为 99%，另一枚反面的概率为 99%，随机拿出一枚投掷两次，事件 A 为第一次为正面，事件 B 为第二次为正面，事件 C 为拿出的是第一枚硬币。P(B) = 0.5 而 P(B|A) = 0.9802，说明 A 和 B 不独立，但如果 C 已经发生，即已知了拿出的是第一枚硬币，那么 A 和 B 就（条件）独立了</p></li><li><p>(*) 思考题：两两独立，是否包含独立？为什么？<br>两两独立的事件不一定相互独立。比如事件A为第一次掷骰子为奇数，B为第二次掷骰子为奇数，C为两次掷骰子的和为奇数。而互相独立一定两两独立。</p></li></ol><ol start="18"><li><p>(*) 思考题：以下结论是否成立：$P(A_1\cap A_2\cap A_3)=P(A_1)P(A_2)P(A_3)$不包含独立？为什么？<br>设实验是掷两个均匀的骰子<br>事件A为第一次扔得1，2或3，事件B为第一次扔得3，4，5，事件C为两次扔得的点数之和为9<br>可得事件两两之间不独立</p></li><li><p>思考题：你能否用计算机近似计算：一副扑克牌（54张）随机发给3个人，每人18张。三个人中有人拿到一副同花顺（花色相同，数字连续，序列是：2-10, J, Q, K, A）的可能性有多少？</p><p>解：</p><p>At the first time, l thought the permutation and combination method in this problem was too complex, and the previous answer has definitely double-counted a lot of cases. </p><p>Besides, according to my experience, the possibility to get a straight flush is very low, so l think the previous answer must be greater than the truth.</p><p>Actually, there do have a lot of double-counted cases, but it turns out that there are also a lot of cases omitted. And l did think of solving it with Monte Carlo method, but the sample space is as large as ${ {54}\choose {18} } { {36}\choose {18} }/6=1.4\times 10^{23}$, l thought it would at least take up $1\%$ of sample space for Monte Carlo to get the valid answer. However, surprisingly, only $10^6$ random cases can approximately converge. l had run the program 10 times, and got the average, the answer is about 0.202148. l was very surprised and amazed. It was definitely an unforgettable experience.</p><p>answers: 0.19982 0.20529 0.20412 0.20205 0.20068 0.20005 0.203 0.20067 0.20297 0.20283</p><p>average: 0.202148</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> tqdm <span class="token keyword">import</span> tqdm<span class="token keyword">def</span> <span class="token function">validate</span><span class="token punctuation">(</span>card<span class="token punctuation">)</span><span class="token punctuation">:</span>    count<span class="token operator">=</span><span class="token number">1</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>card<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> card<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>card<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span>            count <span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">if</span> count<span class="token operator">==</span><span class="token number">5</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            count<span class="token operator">=</span><span class="token number">1</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token comment" spellcheck="true">#validate the existance of straight_flush</span><span class="token keyword">def</span> <span class="token function">judge</span><span class="token punctuation">(</span>card<span class="token punctuation">)</span><span class="token punctuation">:</span>    diamond<span class="token punctuation">,</span> spade<span class="token punctuation">,</span> club<span class="token punctuation">,</span> heart <span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> card<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">>=</span><span class="token number">52</span><span class="token punctuation">:</span>            <span class="token keyword">continue</span>        <span class="token keyword">if</span> card<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">4</span> <span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            diamond<span class="token punctuation">.</span>append<span class="token punctuation">(</span>card<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">//</span><span class="token number">4</span><span class="token punctuation">)</span>        <span class="token keyword">elif</span> card<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">4</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>            spade<span class="token punctuation">.</span>append<span class="token punctuation">(</span>card<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">//</span><span class="token number">4</span><span class="token punctuation">)</span>        <span class="token keyword">elif</span> card<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">4</span><span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">:</span>            club<span class="token punctuation">.</span>append<span class="token punctuation">(</span>card<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">//</span><span class="token number">4</span><span class="token punctuation">)</span>        <span class="token keyword">elif</span> card<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">4</span><span class="token operator">==</span><span class="token number">3</span><span class="token punctuation">:</span>            heart<span class="token punctuation">.</span>append<span class="token punctuation">(</span>card<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">//</span><span class="token number">4</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#classification</span>    diamond<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>    spade<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>    club<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>    heart<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> validate<span class="token punctuation">(</span>diamond<span class="token punctuation">)</span> <span class="token operator">or</span> validate<span class="token punctuation">(</span>spade<span class="token punctuation">)</span> <span class="token operator">or</span> validate<span class="token punctuation">(</span>club<span class="token punctuation">)</span> <span class="token operator">or</span> validate<span class="token punctuation">(</span>heart<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">1</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python">card<span class="token operator">=</span>np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">54</span><span class="token punctuation">)</span><span class="token punctuation">)</span>test_times<span class="token operator">=</span><span class="token number">100000</span>straight_flush<span class="token operator">=</span><span class="token number">0</span><span class="token keyword">for</span> i <span class="token keyword">in</span> tqdm<span class="token punctuation">(</span>range<span class="token punctuation">(</span>test_times<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span>card<span class="token punctuation">)</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        start <span class="token operator">=</span> j<span class="token operator">*</span><span class="token number">18</span>        <span class="token keyword">if</span> judge<span class="token punctuation">(</span>card<span class="token punctuation">[</span>start<span class="token punctuation">:</span>start<span class="token operator">+</span><span class="token number">18</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>            straight_flush<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">break</span>     <span class="token comment" spellcheck="true">#deal again</span>rate<span class="token operator">=</span>straight_flush<span class="token operator">/</span>test_times<span class="token keyword">print</span><span class="token punctuation">(</span>rate<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> assignment </category>
          
      </categories>
      
      
        <tags>
            
            <tag> probability theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Document Object Model</title>
      <link href="/2020/03/21/document-object-model/"/>
      <url>/2020/03/21/document-object-model/</url>
      
        <content type="html"><![CDATA[<p>The DOM is an object-based representation of the source HTML document. It has some differences compared with the source HTML document, but it is essentially an attempt to convert the structure and content of the HTML document into an object model that can be accessed by various programs.</p><p>There are two cases when the DOM can be different from the source HTML.</p><p>The first case is when HTML source code is not valid.</p><p>When the HTML code has some mistakes, during the processing of the DOM, the browser may correct some mistakes in the HTML code to form the valid HTML document as the DOM must be a valid interface. But sometimes HTML can be so broken that the browser can’t correct at all.</p><p>Changing content in the DOM will change the view of the web page, but it will not change the HTML source code.</p><p>The second case is when the DOM is modified by JavaScript.</p><p>DOM is a living model that can be modified by JavaScript, it provides an interface for JavaScript to modify the content, structure, or styling of the page.</p><p>Adding JavaScript programs will change the DOM, but will also not change the HTML source code.</p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> frontend </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Exercise 1 of Mathematical Foundation of Data Science &amp; Engineering</title>
      <link href="/2020/03/17/exercise-1-of-mathematical-foundation-of-data-science-engineering/"/>
      <url>/2020/03/17/exercise-1-of-mathematical-foundation-of-data-science-engineering/</url>
      
        <content type="html"><![CDATA[<h1 id="数学基础第一次作业"><a href="#数学基础第一次作业" class="headerlink" title="数学基础第一次作业"></a>数学基础第一次作业</h1><p><img src="0.png" alt></p><p><strong>1</strong>. $\begin{pmatrix} -1 &amp; -4 &amp; 2\\ -5 &amp; 2 &amp; 1\\ \end{pmatrix}$</p><p><strong>2</strong>. $w^{cat}=\begin{bmatrix} 1 \\ 0\\0\\0 \end{bmatrix}$,$w^{dog}=\begin{bmatrix} 0\\1\\0\\0\end{bmatrix}$,$w^{parrot}=\begin{bmatrix} 0\\0\\1\\0\end{bmatrix}$,$w^{human}=\begin{bmatrix} 0\\0\\0\\1\end{bmatrix}$</p><p><strong>3</strong>. 计算IDF值：$idf_{I}=\frac{4}{3},idf_{you}=\frac{4}{3},idf_{know}=\frac{4}{4},idf_{that}=\frac{4}{2}$</p><p>计算TF值：$tf_{I}=\frac{4}{17},tf_{you}=\frac{3}{17},tf_{know}=\frac{7}{17},tf_{that}=\frac{3}{17}$</p><p>TF-IDF值：$tfidf_{I}=0.068,tfidf_{you}=0.051,tfidf_{know}=0,tfidf_{that}=0.122$</p><p><strong>4</strong>. 线性分类器的评分函数形式：$f(W; b; x_i) = Wx_i + b$</p><p>其中，xi 表示第i 张图像转换的大小为D × 1 的列向量。<br>评分函数的参数包括W 和b，W 是K × D 的矩阵，b 是K × 1 的列向量，K 表示类别的数量。</p><p>线性分类器主要有两部分组成：<br><strong>评分函数</strong>：原始图像数据到类别标签得分的映射;<br><strong>损失函数</strong>：用来量化预测标签的得分与真实标签之间的一致性。<br>该方法可以转化为一个最优化问题，在最优化过程中，将通过更新评分函数的参数来最小<br>化损失函数值。</p><p>引入两种简单的损失函数：</p><p>0-1 损失函数：<br>$L(Y,f(X)) =\begin{cases} 1 &amp; Y\neq f(X) \\ 0&amp; Y=f(X) \end{cases}$</p><p>平方损失函数：<br>$L(Y,f(X)) = (Y − f(X))^2$</p><p><strong>5</strong>. 为了方便损失函数计算，使用Softmax函数将一组$(-\infty,+\infty)$ 的得分$f$ 转换为一组$(0,1)$ 概率，并且这组概率的和为$1$。每张训练图像属于类别 $i$ 的概率得分用公式表示为：</p><p>$$p_{i}=\frac{e^{f_{i}}}{\sum_{j=1}^{K} e^{f_{j}}}$$</p><p>根据预测类别的概率得分，使用交叉熵函数作为损失函数，计算真实标签与预测标签之间的损失。<br>将标签 $y $ 转换为 $one − hot $ 向量$y$，例如真实标签为 4，则 $y = [0; 0; 0; 0; 1]$。<br>每张训练图像对应的交叉熵损失用公式表示为：</p><p>$$l=-\sum_{c=1}^{K} \boldsymbol{y}_{c} \log \left(\boldsymbol{p}_{c}\right)$$</p><p>其中, $K$ 是类别的数量；$y_c$ 表示当前图像的指示变量，如果预测标签与真实标签相同就<br>是$1$，否则为$0$；$p_c$ 是当前图像属于类别 $c$ 的概率得分。</p><p>显然每张图像只需要计算一个类别的概率得分和真实标签的交叉熵。因此第i 张图像的交<br>叉损失函数又可以表示为：</p><p>$$l_{i}=-\log \left(\frac{e^{f_{y_{i}}}}{\sum_{j=1}^{K} e^{f_{j}}}\right)=-f_{y_{i}}+\log \left(\sum_{j=1}^{K} e^{f_{j}}\right)$$</p><p>其中, $K$ 是类别的数量；$y_c$ 表示第$i$张图像的类别标签$ID$；$p_c$ 是当前图像属于类别 $c$ 的概率得分。</p><p>由概率得分公式可得，此时模型给各个数据的概率评分分别为：</p><p>$\begin{pmatrix} \frac{e^2}{e^2+e^8} \\ \frac{e^8}{e^2+e^8} \end{pmatrix}$，$\begin{pmatrix} \frac{e^1}{e^1+e^9} \\ \frac{e^9}{e^1+e^9} \end{pmatrix}$，$\begin{pmatrix} \frac{e^3}{e^3+e^2} \\ \frac{e^2}{e^3+e^2} \end{pmatrix}$，$\begin{pmatrix} \frac{e^1}{e^1+e^5} \\ \frac{e^5}{e^1+e^5} \end{pmatrix}$，$\begin{pmatrix} \frac{e^2}{e^2+e^0} \\ \frac{e^0}{e^2+e^0} \end{pmatrix}$</p><p>由交叉熵损失函数可得，各个数据的交叉熵损失分别为：</p><p>$-ln(\frac{e^8}{e^2+e^8})$,$-ln(\frac{e^9}{e^1+e^9})$,$-ln(\frac{e^2}{e^3+e^2})$,$-ln(\frac{e^1}{e^1+e^5})$,$-ln(\frac{e^2}{e^2+e^0})$</p><p><strong>6</strong>. <strong>结构风险(structural risk)</strong><br>在假设空间、损失函数以及训练数据集确定的情况下，结构风险定义为在经验风险上加上<br>表示模型复杂度的正则化项或罚项：</p><p>$$R_{s r m}(f)=\frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)+\lambda J(f)$$</p><p>其中$J_(f)$ 为模型的复杂度，是定义在假设空间F 上的泛函。模型f 越复杂，复杂度$J_(f)$ 就<br>越大；反之，模型f 越简单，复杂度$J_(f)$ 就越小。也就是说，复杂度表示了对复杂模型的<br>惩罚。$\lambda$ ≥ 0 是系数，用以权衡经验风险和模型复杂度。结构风险小需要经验风险与模型复<br>杂度同时小。结构风险小的模型往往对训练数据以及未知的测试数据都有较好的预测。</p><p><strong>结构风险最小化准则(structural risk minimization, SRM)</strong><br>结构风险最小化策略认为结构风险最小的模型是最优的模型。所以求最优模型，就是求解<br>最优化问题：</p><p>$$\min _{f \in \mathcal{F}} \frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)+\lambda J(f)$$</p><p>上述最优化问题一般也称为<strong>正则化(regularization)</strong>，正则化是结构风险最小化策略的实现。</p><p>在本题中，引入<strong>最小二乘问题</strong>的损失函数：</p><p>$$\min _{\boldsymbol{\theta}} \frac{1}{N}|\boldsymbol{y}-\boldsymbol{X} \boldsymbol{\theta}|^{2}$$</p><p>通过添加仅涉及$\theta$ 的正则项可以改善最小二乘问题的稳定性。<br>比如添加易于计算导数的$L_2$正则项：</p><p>$$\min _{\boldsymbol{\theta}} \frac{1}{N}|\boldsymbol{y}-\boldsymbol{X} \boldsymbol{\theta}|^{2}+\frac{\lambda}{2}|\boldsymbol{\theta}|_{2}^{2}$$</p><p>也可以添加$L_1$正则项得到参数更为稀疏的模型：</p><p>$$\min _{\boldsymbol{\theta}} \frac{1}{N}|\boldsymbol{y}-\boldsymbol{X} \boldsymbol{\theta}|^{2}+\lambda|\boldsymbol{\theta}|_{1}$$</p>]]></content>
      
      
      <categories>
          
          <category> exercises </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mathematical Foundation of Data Science &amp; Engineering </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>first assignment of probability theory</title>
      <link href="/2020/03/14/first-assignment-of-probability-theory/"/>
      <url>/2020/03/14/first-assignment-of-probability-theory/</url>
      
        <content type="html"><![CDATA[<h1 id="概率论第一次作业"><a href="#概率论第一次作业" class="headerlink" title="概率论第一次作业"></a>概率论第一次作业</h1><p>textbook:”Introduction to Probability, 2E”<br>Dimitri P.Bertsekas,John N.Tsitsiklis<br>郑忠国 童行伟 译  人民邮电出版社</p><ol><li><p>第一章习题5（p48）</p><p>解：A = “学生是天才”，B=”学生喜欢巧克力”</p><p>$P( A \cup B) = P(A) + P(B) - P(A \cap B) = 0.6+0.7-0.4=0.9$</p><p>$P(A^C \cap B^C) = 1-P(A \cup B)=1-0.9=0.1$</p></li></ol><ol start="2"><li><p>第一章习题7（p48）</p><p>解：骰子有四个面，分别为1，2，3，4，连续抛若干次，直到第一次出现偶数面为止。</p><p>如果第n次抛出了偶数面，则结果序列为$(a_{1},a_{2},a_{3},…,a_{n})$ ，其中，$a_{1},a_{2},a_{3},…a_{n-1}\in\lbrace1,3\rbrace$ ,</p><p>$a_{n}\in\lbrace2,4\rbrace$ </p><p>如果始终没有抛出偶数面，则结果序列为$(a_{1},a_{2},a_{3},…)$ ，其中每个元素属于$\lbrace1,3\rbrace$</p><p>样本空间即包含以上两种类型中的所有可能的情况</p></li></ol><ol start="3"><li><p>第一章习题9（p48）</p><p>解：</p><p>a)</p><p>$P(A)=P(A \cap \Omega) = P(A \cap (\cup^{n}_{i=1}S_{i}))=P((A \cap S_{1}) \cup (A \cap S_{2})… \cup(A \cap S_{n})) = \sum^{n}_{i=1}P(A \cap S_{i})$</p><p>b)</p><p>$\because P(A)= \sum^{n}_{i=1}P(A \cap S_{i})$</p><p>$\because P(B \cup C \cup (B^C \cap C^C)) - P(B \cap C)= \Omega$</p><p>$ \therefore P(A)=P(A \cap B)+P(A \cap C)+P(A \cap B^{C} \cap C^{C})-P(A \cap B \cap C)$</p></li></ol><ol start="4"><li><p>第一章习题10（p48）</p><p>证明：</p><p>$ P((A \cap B^{C}) \cup (A^{C} \cap B)) $</p><p>$= P(A \cap B^C)+P(A^C \cap B)-P(A\cap B^{C}\cap A^{C}\cap B)$</p><p>$= P(A\cap (\Omega-B))+P((\Omega-A)\cap B)$</p><p>$=P(A)+P(B)-2P(A\cap B)$</p></li></ol><ol start="5"><li><p>思考题：你能否证明快速排序的平均复杂度是$O(n\log n)$？</p><p>证明：</p><p>$T(n)=2T(n/2)+n$ ，由Master Theorem可得其平均复杂度为 $O(n\log n)$</p></li></ol><ol start="6"><li><p>思考题：一副扑克牌（54张）随机发给3个人，每人18张。三个人中有人拿到一副同花顺（花色相同，数字连续，序列是：2-10, J, Q, K, A）的可能性有多少？</p><p>解：</p><p>如果题目中的同花顺，为传统意义上的同花顺，即连续五张及以上的同花，那么必须手动考虑很多情况，在这过程中还会出现很多重复情况，列出来计算很复杂；如果使用计算机，用蒙特卡洛方法破解，样本空间太大也不行。</p><p>由于题目对同花顺的定义不明确，如果同花顺是花色相同的序列2-10,J,Q,K,A，那么用容斥原理可解。</p><p>$P(A\cup B \cup C)=P(A)+P(B)+P(C)-P(A \cap B)-P(A\cap C)-P(B\cap C)+P(A\cap B\cap C)$</p><p>$=3\times {4\choose 1}{41 \choose 5}/{54 \choose 18}-3\times {4\choose 1}{3\choose 1} {28 \choose 5} {23 \choose 5}/{54 \choose 18}{36 \choose 18}+{4\choose 1} {3\choose 1} {2\choose 1}{15 \choose 5}{10 \choose 5}{5 \choose 5}/{54 \choose 18}{36 \choose 18}{18 \choose 18}$</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> exercises </category>
          
      </categories>
      
      
        <tags>
            
            <tag> probability theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在樱花漫天飞舞的时刻</title>
      <link href="/2020/03/03/zai-ying-hua-man-tian-fei-wu-de-shi-ke/"/>
      <url>/2020/03/03/zai-ying-hua-man-tian-fei-wu-de-shi-ke/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=440241194&auto=1&height=66">"></iframe></div><blockquote><p>桜の舞う空の彼方<br>在樱花满空飞舞的他方<br>目を閉じれば心の中<br>如果闭上眼睛就在心里</p></blockquote><p>在樱花漫天飞舞的时刻，你也一定能看得到</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写在开学之前</title>
      <link href="/2020/03/03/xie-zai-kai-xue-zhi-qian/"/>
      <url>/2020/03/03/xie-zai-kai-xue-zhi-qian/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28815250&auto=0&height=66"></iframe></div><blockquote><p>悔不该耽于逸乐，至有今日。</p></blockquote><blockquote><p>直到看见平凡才是唯一的答案。</p></blockquote><p>漫长的寒假就快要结束了，开学在即。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于开源的一点个人理解</title>
      <link href="/2020/03/01/guan-yu-kai-yuan-de-yi-dian-ge-ren-li-jie/"/>
      <url>/2020/03/01/guan-yu-kai-yuan-de-yi-dian-ge-ren-li-jie/</url>
      
        <content type="html"><![CDATA[<p>忽然想到要聊一聊开源，就写下这篇随笔，作为记录。<br>在上大学之前，我知道开源，但是这个词汇在我的生活里出现得还不多。进入大二以来，我逐渐更加了解开源，<br>我把我对开源软件的一些思考和理解，做一些总结。</p><h1 id="开源软件是什么"><a href="#开源软件是什么" class="headerlink" title="开源软件是什么"></a>开源软件是什么</h1><blockquote><p>开源软件（OSS）是与源代码一起分发的软件，可以由用户读取或修改。普遍开源软件应符合自由分发、源代码必须包含在程序中、任何人都必须能够修改源代码、可以重新分发源代码的修改版本等标准。</p></blockquote><p>开源软件到底是什么，是互不相识的程序员通过互联网，协作开发的免费软件吗？<br>那如果是免费软件，开发者的收益在哪里？只是做善事吗？</p><h1 id="开源软件的收益在哪里"><a href="#开源软件的收益在哪里" class="headerlink" title="开源软件的收益在哪里"></a>开源软件的收益在哪里</h1><p>开发软件所需要的工程量往往是很大的，一个人没有足够的时间精力完成，而如果这个软件一般是程序员本人需要用的，或者是其他人需要用的，<br>这样，开发者将自己开发的软件，开源到社区，号召其他程序员帮助自己开发软件。<br>开发者开源的第一个收益，就是借助社区的力量，完成自己的作品，造福自己造福他人。<br>那有人问为什么不用已经发行的商业软件呢？首先商业软件不一定是免费的，其次商业软件的功能以及维护未必能达到用户的需求。<br>对于开发者来说，第二个收益就是在开源协作开发中磨练自己的能力，证明自己的实力。</p><h1 id="开源软件战胜闭源软件"><a href="#开源软件战胜闭源软件" class="headerlink" title="开源软件战胜闭源软件"></a>开源软件战胜闭源软件</h1><p>软件公司开发商业软件，卖给企业和个人使用，并提供技术支持，这样的“软件卖钱”时代（模式），我认为已经过去了，或者说慢慢过去了。<br>在蓝海海域，有开源的地方，闭源的商业软件生长不出来。一定程度上说，计算机技术太复杂了，所以蓝海挺多的，很多琐碎的需求，难以提供一揽子服务，也助长了开源的环境。<br>在红海海域，商业软件比较成熟的地方，我认为开源会逐渐战胜闭源。有的闭源软件工程量太大，功能也比较完善，已经广泛运用，比如windows操作系统，matlab，我觉得不太可能被开源打败。在越来越多的领域，出现了功能强大的开源软件，足以替代商业软件。</p><h1 id="开源和开源的竞争"><a href="#开源和开源的竞争" class="headerlink" title="开源和开源的竞争"></a>开源和开源的竞争</h1><p>随着越来越多的企业加入开源，有一种说法是，现在已经不是开源和闭源的竞争，而是开源和开源的竞争。这样竞争的收益是什么呢？<br>我个人的理解是：<br>1，开源软件竞争的是，技术标准的领导权。<br>2，开源软件竞争的是，平台的生态，用户规模和数据。<br>这也符合当下互联网经济的特点，有流量就有利润。为了迅速占领市场，让更多开发者和普通用户拥抱自家的软件（平台），企业不仅开放平台，甚至还让利。<br>可以预见未来开源和开源的竞争还会更加激烈。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
