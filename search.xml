<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Leetcode14最长公共前缀</title>
      <link href="/2020/06/16/leetcode14-zui-chang-gong-gong-qian-zhui/"/>
      <url>/2020/06/16/leetcode14-zui-chang-gong-gong-qian-zhui/</url>
      
        <content type="html"><![CDATA[<p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 “”。</p><p>示例 1:</p><p>输入: [“flower”,”flow”,”flight”]<br>输出: “fl”<br>示例 2:</p><p>输入: [“dog”,”racecar”,”car”]<br>输出: “”<br>解释: 输入不存在公共前缀。<br>说明:</p><p>所有输入只包含小写字母 a-z 。</p><p>题解：<br>python有两种解法利用了语言的特性，十分短小精悍。<br>我每次新看到一个python的语法特性的时候，我内心都要波动一会，这个语言怎么有那么多不讲道理的语法，怎么有那么多语法糖。高中vb语言，再加上大学一年c语言，感觉我的程序思维完全被vb和c语言塑造了。</p><p>from xshura:<br>1、利用python的max()和min()，在Python里字符串是可以比较的，按照ascII值排，举例abb， aba，abac，最大为abb，最小为aba。所以只需要比较最大最小的公共前缀就是整个数组的公共前缀</p><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">longestCommonPrefix</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> strs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> strs<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token string">""</span>        s1 <span class="token operator">=</span> min<span class="token punctuation">(</span>strs<span class="token punctuation">)</span>        s2 <span class="token operator">=</span> max<span class="token punctuation">(</span>strs<span class="token punctuation">)</span>        <span class="token keyword">for</span> i<span class="token punctuation">,</span>x <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> x <span class="token operator">!=</span> s2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> s2<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> s1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、利用python的zip函数，把str看成list然后把输入看成二维数组，左对齐纵向压缩，然后把每项利用集合去重，之后遍历list中找到元素长度大于1之前的就是公共前缀</p><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">longestCommonPrefix</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> strs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> strs<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token string">""</span>        ss <span class="token operator">=</span> list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>set<span class="token punctuation">,</span> zip<span class="token punctuation">(</span><span class="token operator">*</span>strs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token string">""</span>        <span class="token keyword">for</span> i<span class="token punctuation">,</span> x <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>ss<span class="token punctuation">)</span><span class="token punctuation">:</span>            x <span class="token operator">=</span> list<span class="token punctuation">(</span>x<span class="token punctuation">)</span>            <span class="token keyword">if</span> len<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">break</span>            res <span class="token operator">=</span> res <span class="token operator">+</span> x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>I/O subsystem</title>
      <link href="/2020/06/15/io-subsystem/"/>
      <url>/2020/06/15/io-subsystem/</url>
      
        <content type="html"><![CDATA[<p>在vmware虚拟机MINIX3中在MINIX3 中安装一块100MB 大小的RAM 盘，可以挂载并且存取文件操作，虚拟机MINIX3硬盘基于ssd</p><p>测试RAM 和DISK 盘的文件读写速度，并分析读写速度有差异的原因。</p><p>第一步：增加RAM盘：<br>修改/usr/src/minix/drivers/storage/memory/memory.c ，增加默认的用户<br>RAM盘数：RAMDISKS=7。</p><p>重新编译内核，重启reboot。</p><p>创建设备mknod /dev/myram b 1 13，</p><p>/<em>mknod 的使用方式</em>/<br>mknod DEVNAME{b|c} MAJOR MINOR<br>DEVNAME 创建的设备文件名，这里为/dev/myram</p><p>b:块设备：系统从设备中读取数据的时候，直接从内存的buffer 中读取数据，而不经过磁盘。<br>MAJOR 和MINOR 表示主设备号和次设备号。</p><p>查看设备是否创建成功输入ls<br>/dev/ | grep ram。</p><p><img src="https://gitee.com/wu_lin_long/image/raw/master/IO_subsystem/20200615163107.jpg" alt="img"></p><p>实现buildmyram初始化工具（用于分配容量）。</p><ol><li>在/usr/src/minix/commands/目录下新建buildmyram 文件夹，<br>参照 /usr/src/minix/commands/ramdisk 文件增加buildmyram 也作为minix 的内置命令。</li><li>编写buildmyram.c 文件<br>类比ramdisk.c，修改<code>PATH</code>变量。<br>然后再buildmyram文件下新建Makefile，在commands目录下修改Makefile<br>编译buildmyram.c文件，即可将buildmyram作为新增对的commands内置命令</li></ol><p><img src="https://gitee.com/wu_lin_long/image/raw/master/IO_subsystem/20200615163208.jpg" alt="img"></p><p>在ram盘上创建内存文件系统：<br>mkfs.mfs /dev/myram</p><p>将ram盘挂载到用户目录下，mount /dev/myram /root/myram,查看是否挂在成功：输入df<br>提前在root下创建一个directory， myram</p><p><img src="https://gitee.com/wu_lin_long/image/raw/master/IO_subsystem/20200615163226.jpg" alt="img"></p><p>二、性能测试<br>性能测试的文件：</p><ol><li>多线程并发的同步读写</li><li>并发的数目要增加到设备接近“饱和“的状态，在出现饱和之前，总吞吐量随着并发数线性增长</li><li>性能测试的二个变量为“块大小”（推荐64B/256B/1KB/4KB/8KB）和“块扫描方式”（顺序/随机）可以画四张曲线图对比RAM盘和Disk盘性能（随机读，随机写，顺序读，顺序写）。实验结果预计为RAM盘性能高于DISK盘，特别是随机读写性能。</li></ol><p>在disk顺序写的情况下，blocksize为8192B的情况下，并发数和吞吐率的关系如下</p><p>blocksize    concurrency    per time    mBps<br>8192    1    0.0733    106.5825<br>8192    2    0.12915    60.49168<br>8192    3    0.082767    94.39187<br>8192    4    0.072075    108.394<br>8192    5    0.06366    122.7223<br>8192    6    0.060267    129.6322<br>8192    7    0.057143    136.7188<br>8192    8    0.058537    133.4615<br>8192    9    0.0624    125.2003<br>8192    10    0.05483    142.4859<br>8192    11    0.053182    146.9017<br>8192    12    0.176108    44.3619<br>8192    13    0.177046    44.12691</p><p><img src="https://gitee.com/wu_lin_long/image/raw/master/IO_subsystem/20200615165152.png" alt="img"></p><p>在并发达到12的时候开始有明显的clashing，所以综合考虑，在本次实验中选择并发数为10进行实验。</p><p>由于实验基于ssd，而且磁盘设置大小设置得比较小，只有100兆，受缓存的影响比较大，导致吞吐率过高。<br>写测试如下：<br>并发数    blocksize    ram顺序写    disk顺序写    ram随机写    disk随机写<br>10    64    12.207031    11.451249    7.629395    6.541817<br>10    128    22.194602    23.657037    15.590078    12.41814<br>10    256    40.690104    43.134386    29.919194    27.126736<br>10    512    75.120192    73.315503    59.838388    49.672558<br>10    1024    162.760417    91.609991    76.115549    102.796053<br>10    2048    300.480769    116.050208    165.099324    202.186853<br>10    4096    617.101106    134.698276    266.456344    172.38526<br>10    8192    976.5625    142.045455    426.213857    337.327288<br>很明显ram顺序写和随机写都比disk要快，由于是SSD，所以disk随机写的速度并不比ram随机写慢很多，而且有两个值还超过了ram随机写。值得注意的是disk的顺序写比disk的随机写要慢，实际上这是不符合逻辑的。</p><p><img src="https://gitee.com/wu_lin_long/image/raw/master/IO_subsystem/20200615165210.png" alt="img"></p><p><img src="https://gitee.com/wu_lin_long/image/raw/master/IO_subsystem/20200615165219.png" alt="img"></p><p>读测试如下：<br>并发数    blocksize    ram顺序读    disk顺序读    ram随机读    disk随机读<br>10    64    10.172526    13.097673    7.180607    6.781684<br>10    128    21.567193    25.273357    14.095879    13.824497<br>10    256    39.633218    48.828125    26.652907    27.648995<br>10    512    77.137638    94.628149    53.305813    54.253472<br>10    1024    172.53754    167.50643    97.65625    110.59598<br>10    2048    404.37371    244.14063    186.011905    209.338156<br>10    4096    868.05556    360.6879    344.770521    366.439962</p><p>可以发现ram顺序读比disk顺序读要快，但是ram随机读和disk随机读速度差不多。</p><p>  <img src="https://gitee.com/wu_lin_long/image/raw/master/IO_subsystem/20200615165231.png" alt="img"></p><p><img src="https://gitee.com/wu_lin_long/image/raw/master/IO_subsystem/20200615165247.png" alt="img"></p><ol><li><p>四、 总结</p><p>理论上，顺序读写比随机读写快，因为顺序不像随机一样，会造成大量的磁盘碎片。</p><p>RAM理论上读写性能好于机械硬盘，因为在机械硬盘中存在机械结构，读取和写入需要由磁头在转动的硬盘上寻找文件所在的扇区。在机械硬盘io的时候，寻道时间和旋转延迟非常影响硬盘速度。而SSD则运用了闪存技术，消除了机械结构，缩短了硬盘和RAM速度的差距，本次实验由于是在SSD上，所以差距体现并不如机械硬盘上明显。同时，缓存的大小对实验结果也有影响。这次实验结果偏高可能同时有ssd和缓存的影响，尤其是在磁盘设置100MB不是很大的情况下，缓存的影响相对就更大了，导致此次实验吞吐率偏高。</p></li></ol><p>   五、 改进建议</p><ol><li><p>建议增大磁盘的容量，至少1G以上，这样削弱缓存的影响。</p></li><li><p>每做一次读或者写的操作，就重新加载一次磁盘，避免缓存的影响。</p></li><li><p>判断读写测试函数的返回值，这样以免读写发生错误。</p></li><li><p>增大随机读写时rand（）函数的范围</p></li></ol><p>To be honest, there are a lot of difficulties during the experiment and I am not quite sure why the results did not meet expectations. I will leave it to the future when l have improved my knowledge and skills and then it will be appropriate to experiment it again.</p>]]></content>
      
      
      <categories>
          
          <category> operating system </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operating system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode996正方形数组的数目</title>
      <link href="/2020/06/14/leetcode996-zheng-fang-xing-shu-zu-de-shu-mu/"/>
      <url>/2020/06/14/leetcode996-zheng-fang-xing-shu-zu-de-shu-mu/</url>
      
        <content type="html"><![CDATA[<p>‘’’<br>给定一个非负整数数组 A，如果该数组每对相邻元素之和是一个完全平方数，则称这一数组为正方形数组。</p><p>返回 A 的正方形排列的数目。两个排列 A1 和 A2 不同的充要条件是存在某个索引 i，使得 A1[i] != A2[i]。</p><p>示例 1：</p><p>输入：[1,17,8]<br>输出：2<br>解释：<br>[1,8,17] 和 [17,8,1] 都是有效的排列。<br>示例 2：</p><p>输入：[2,2,2]<br>输出：1</p><p>提示：</p><p>1 &lt;= A.length &lt;= 12<br>0 &lt;= A[i] &lt;= 1e9</p><p>‘’’</p><p>‘’’<br>这道题可以构造一张图，每个数作为一个节点，如果两个数加起来满足是一个完全平方数，就连一条边。<br>我们的目标就是求这张图的所有哈密顿路径，即经过图中所有点仅一次的路径。</p><p>‘’’</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token keyword">def</span> <span class="token function">numSquarefulPerms</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">:</span>        N <span class="token operator">=</span> len<span class="token punctuation">(</span>A<span class="token punctuation">)</span>        count <span class="token operator">=</span> collections<span class="token punctuation">.</span>Counter<span class="token punctuation">(</span>A<span class="token punctuation">)</span>        graph <span class="token operator">=</span> <span class="token punctuation">{</span>x<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> count<span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">#把count中的元素x都保存成一个集合</span>        <span class="token keyword">for</span> x <span class="token keyword">in</span> count<span class="token punctuation">:</span>            <span class="token keyword">for</span> y <span class="token keyword">in</span> count<span class="token punctuation">:</span>                <span class="token keyword">if</span> int<span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">+</span>y<span class="token punctuation">)</span><span class="token operator">**</span><span class="token punctuation">.</span><span class="token number">5</span> <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span> <span class="token operator">==</span> x<span class="token operator">+</span>y<span class="token punctuation">:</span>                    graph<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>y<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#构造一个图，每个数作为一个节点，两个节点如果符合条件的话，就连一条边</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> todo<span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token comment" spellcheck="true">#dfs，传入两个参数，第一个参数是某个数，第二个参数是总长度减一</span>            count<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">-=</span><span class="token number">1</span>    <span class="token comment" spellcheck="true">#x的count减一，表示已经经历过一次这个数了，当然一个数字是可以重复次数的，count不一定是1</span>            <span class="token keyword">if</span> todo <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">:</span>   <span class="token comment" spellcheck="true">#如果todo是0的话，ans就置为1 ,作为递归终结的条件</span>                ans <span class="token operator">=</span> <span class="token number">1</span>                 <span class="token keyword">else</span><span class="token punctuation">:</span>                ans <span class="token operator">=</span> <span class="token number">0</span>     <span class="token comment" spellcheck="true">#如果todo不是0的话，ans置为0，防止递归的时候出错。</span>                <span class="token keyword">for</span> y <span class="token keyword">in</span> graph<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">:</span>   <span class="token comment" spellcheck="true">#对每个y in graph[x] ，即对每个x的临边</span>                    <span class="token keyword">if</span> count<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#如果count【y】不是0的话，即如果不是这个数都被遍历过一边的话</span>                        ans <span class="token operator">+=</span> dfs<span class="token punctuation">(</span>y<span class="token punctuation">,</span> todo <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#就递归寻找路径，dfs的第一个参数是x相邻的y，第二个参数是todo-1</span>            count<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token comment" spellcheck="true">#回溯步骤，本来x设置为遍历过了，count【x】+1返回没有遍历的状态。</span>            <span class="token keyword">return</span> ans           <span class="token keyword">return</span> sum<span class="token punctuation">(</span>dfs<span class="token punctuation">(</span>x<span class="token punctuation">,</span> len<span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> count<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#对每个不重复的x开头的，求其通路的数目，再求和</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>little tricks</title>
      <link href="/2020/05/20/little-tricks/"/>
      <url>/2020/05/20/little-tricks/</url>
      
        <content type="html"><![CDATA[<p>解决从github git clone速度慢的问题：</p><p>只需要将 <a href="http://www.github.com/" target="_blank" rel="noopener">www.github.com/</a> 后面为代码库 改为</p><p><a href="http://www.github.com.cnpmjs.org/" target="_blank" rel="noopener">www.github.com.cnpmjs.org/</a> 后面为代码库地址就可以实现一键式加速。</p><p>设置git的缓存大小：</p><p>git config http.postBuffer 524288000</p><p>filezilla：<br>开了代理是连接不上远程服务器的，除非手动设置一下代理服务器<br>用本机ssh连接虚拟机选用主机模式，上外网用NAT</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Birthday Problem</title>
      <link href="/2020/05/15/birthday-problem/"/>
      <url>/2020/05/15/birthday-problem/</url>
      
        <content type="html"><![CDATA[<h2 id="birthday-problem"><a href="#birthday-problem" class="headerlink" title="birthday problem"></a>birthday problem</h2><p>Coincidentally, during the first year of high school, three people in the class had the same birthday. It was easy to calculate the probability of two or more people having the same birthday, however, I was curious about the probability of three or more people.<br>It turns out to be around 6.6%, and the probability of only two people having the same birthday is around 82.5%, which is consistent with perceptual cognition.</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#计算40个人当中，只有两个人生日相同的概率</span><span class="token keyword">import</span> mathSn <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> n <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">42</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#n是选出来结对的人</span>    <span class="token comment" spellcheck="true">#在可能的40个人所结成的780种可能的对子中，找出n/2对，然后把每一对看成一个人</span>    pairs <span class="token operator">=</span> <span class="token number">1</span>    temp <span class="token operator">=</span> n    <span class="token comment" spellcheck="true">#计算pairs</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>temp <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>        pairs <span class="token operator">=</span> pairs <span class="token operator">*</span> math<span class="token punctuation">.</span>comb<span class="token punctuation">(</span><span class="token number">42</span> <span class="token operator">-</span> temp<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>        temp <span class="token operator">-=</span> <span class="token number">2</span>    <span class="token comment" spellcheck="true"># 去除重复的pairs</span>    pairs <span class="token operator">=</span> pairs <span class="token operator">/</span> math<span class="token punctuation">.</span>perm<span class="token punctuation">(</span>int<span class="token punctuation">(</span>n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> int<span class="token punctuation">(</span>n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#print(pairs)</span>    <span class="token comment" spellcheck="true">#计算在挑出n个人结对之后，所产生的可能的概率</span>    Pn <span class="token operator">=</span> pairs <span class="token operator">*</span> math<span class="token punctuation">.</span>perm<span class="token punctuation">(</span><span class="token number">365</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token operator">-</span>int<span class="token punctuation">(</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">/</span>math<span class="token punctuation">.</span>pow<span class="token punctuation">(</span><span class="token number">365</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#累计</span>    Sn <span class="token operator">=</span> Sn <span class="token operator">+</span> Pn<span class="token comment" spellcheck="true">#print('%.10f' % Sn)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> mathp <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> math<span class="token punctuation">.</span>perm<span class="token punctuation">(</span><span class="token number">365</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token operator">/</span>math<span class="token punctuation">.</span>pow<span class="token punctuation">(</span><span class="token number">365</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'高一班上至少两人生日相同的概率：%.10f'</span> <span class="token operator">%</span> p<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%e'</span> <span class="token operator">%</span> math<span class="token punctuation">.</span>perm<span class="token punctuation">(</span><span class="token number">365</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%e'</span> <span class="token operator">%</span> math<span class="token punctuation">.</span>pow<span class="token punctuation">(</span><span class="token number">365</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">)</span>p <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> math<span class="token punctuation">.</span>perm<span class="token punctuation">(</span><span class="token number">365</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token operator">/</span>math<span class="token punctuation">.</span>pow<span class="token punctuation">(</span><span class="token number">365</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">)</span> <span class="token operator">-</span> Sn<span class="token comment" spellcheck="true">#p2 = math.comb(40, 2) * math.perm(365, 39)/math.pow(365,40)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'只有两个人生日相同的概率：%.10lf'</span> <span class="token operator">%</span> Sn<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'至少三人生日相同的概率：%.10f'</span> <span class="token operator">%</span> p<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>高一班上至少两人生日相同的概率：0.89123180983.374555e+1013.102520e+102只有两个人生日相同的概率：0.8243423240至少三人生日相同的概率：0.0668894858</code></pre>]]></content>
      
      
      <categories>
          
          <category> programming practice </category>
          
      </categories>
      
      
        <tags>
            
            <tag> probability theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客从github到阿里云</title>
      <link href="/2020/04/11/hexo-bo-ke-cong-github-dao-a-li-yun/"/>
      <url>/2020/04/11/hexo-bo-ke-cong-github-dao-a-li-yun/</url>
      
        <content type="html"><![CDATA[<p>建站到现在也有一段时间了，一开始只是hexo+github，因为github的服务器在国外，国内访问速度比较慢，所以在码云上又部署了一份，智能解析，国内走码云，国外走github。但是后来发现码云的服务器是腾讯云的，并且不支持阿里云备案的接入，网站无法访问，于是放弃giteepages，决定在阿里云上部署，国内解析走阿里云。</p><p>建站到现在精力基本上都花在定制优化博客上了，文章却没怎么写，希望以后可以多写写文章。</p><p>网上的云服务器部署教程大都是CentOs，而我选的操作系统是Ubuntu 18.04.4 LTS，所以找了很多教程，也花了很多时间，踩了很多坑。下面记录hexo博客阿里云的部署：</p><h3 id="1-安装git和nginx"><a href="#1-安装git和nginx" class="headerlink" title="1.安装git和nginx"></a>1.安装git和nginx</h3><p>首先需要在云服务器上安装git和nginx</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">apt-get</span> update<span class="token function">apt-get</span> <span class="token function">install</span> git-core nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-配置Nginx"><a href="#2-配置Nginx" class="headerlink" title="2.配置Nginx"></a>2.配置Nginx</h3><p> /var/www/blog目录用于放置生成的静态文件</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">mkdir</span> /var/www/blog<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编写nginx配置文件</p><pre class="line-numbers language-bash"><code class="language-bash">vim /etc/nginx/conf.d/blog.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>监听80端口</p><pre class="line-numbers language-bash"><code class="language-bash">server<span class="token punctuation">{</span>    listen 8080<span class="token punctuation">;</span>    root /var/www/blog<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启nginx</p><pre class="line-numbers language-bash"><code class="language-bash">systemctl restart nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果失败，可以看看nginx报什么错，是不是配置写错了，或者是不是正确安装了。</p><p>可以使用</p><pre class="line-numbers language-bash"><code class="language-bash">nginx -t   <span class="token comment" spellcheck="true">#检查nginx配置是否正确</span><span class="token comment" spellcheck="true">#正常情况下会返回：</span><span class="token comment" spellcheck="true">#nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><span class="token comment" spellcheck="true">#nginx: configuration file /etc/nginx/nginx.conf test is successful</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果报端口占用的话，</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">netstat</span> -tlpn   <span class="token comment" spellcheck="true">#观察使用应用使用端口的情况</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用kill + 对应的pid，关闭使用这个端口的程序，</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">kill</span> 3480 <span class="token comment" spellcheck="true">#关掉pid为3480的进程</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-配置Git-Hooks"><a href="#3-配置Git-Hooks" class="headerlink" title="3. 配置Git Hooks"></a>3. 配置Git Hooks</h3><h4 id="创建Git裸仓库"><a href="#创建Git裸仓库" class="headerlink" title="创建Git裸仓库"></a>创建Git裸仓库</h4><p>生成blog.git作为远程Git仓库，Hexo在本地生成的博客静态文件可以通过push与其同步。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">mkdir</span> ~/blog.git <span class="token operator">&amp;&amp;</span> <span class="token function">cd</span> ~/blog.git<span class="token function">git</span> init --bare<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="配置Hooks脚本"><a href="#配置Hooks脚本" class="headerlink" title="配置Hooks脚本"></a>配置Hooks脚本</h4><p>编写post-receive脚本使其在blog.git仓库接收到push时执行。</p><pre class="line-numbers language-bash"><code class="language-bash">vim blog.git/hooks/post-receive<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>脚本非常简单，删除原有的/var/www/blog目录，然后从blog.git仓库clone新的博客静态文件。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token function">rm</span> -rf /var/www/blog<span class="token function">git</span> clone /root/blog.git /var/www/blog<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>给post-receive脚本执行权限</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">chmod</span> +x blog.git/hooks/post-receive<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-部署Hexo博客"><a href="#4-部署Hexo博客" class="headerlink" title="4. 部署Hexo博客"></a>4. 部署Hexo博客</h3><h4 id="在本地hexo修改-config-yml"><a href="#在本地hexo修改-config-yml" class="headerlink" title="在本地hexo修改_config.yml"></a>在本地hexo修改_config.yml</h4><pre><code>deploy:  type: git  repo: root@xx.xx.xx.xx:blog.git     #用户名@你的ip地址:blog.git</code></pre><h4 id="部署博客"><a href="#部署博客" class="headerlink" title="部署博客"></a>部署博客</h4><p>hexo先生成新的博客静态文件，然后通过git将其同步到云服务器的blog.git仓库。</p><pre class="line-numbers language-bash"><code class="language-bash">hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-云安全组和dns解析"><a href="#5-云安全组和dns解析" class="headerlink" title="5.云安全组和dns解析"></a>5.云安全组和dns解析</h3><p>阿里云的服务器后台端口不是默认开放的，需要手动在云安全组里添加<strong>80/443端口</strong>访问许可.</p><p>云服务器的防火墙如果开着，也有可能导致不能访问，</p><pre class="line-numbers language-bash"><code class="language-bash">ufw status <span class="token comment" spellcheck="true">#观察防火墙状态</span>ufw disable <span class="token comment" spellcheck="true">#关闭防火墙</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以用wget测试nginx是不是成功运行</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">wget</span> http://xx.xx.xx.xx  <span class="token comment" spellcheck="true">#你的ip地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6-ssh配置"><a href="#6-ssh配置" class="headerlink" title="6.ssh配置"></a>6.ssh配置</h3><p>将本地的ssh公钥传到服务器上</p><pre class="line-numbers language-bash"><code class="language-bash">ssh-copy-id root@xx.xx.xx.xx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>公钥验证的原理是，服务器发送一段字符给客户，客户私钥签名之后发回去，服务器再用公钥验证，验证通过就建立连接，这样就实现了免密登录。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Document Object Model</title>
      <link href="/2020/03/21/document-object-model/"/>
      <url>/2020/03/21/document-object-model/</url>
      
        <content type="html"><![CDATA[<p>The DOM is an object-based representation of the source HTML document. It has some differences compared with the source HTML document, but it is essentially an attempt to convert the structure and content of the HTML document into an object model that can be accessed by various programs.</p><p>There are two cases when the DOM can be different from the source HTML.</p><p>The first case is when HTML source code is not valid.</p><p>When the HTML code has some mistakes, during the processing of the DOM, the browser may correct some mistakes in the HTML code to form the valid HTML document as the DOM must be a valid interface. But sometimes HTML can be so broken that the browser can’t correct at all.</p><p>Changing content in the DOM will change the view of the web page, but it will not change the HTML source code.</p><p>The second case is when the DOM is modified by JavaScript.</p><p>DOM is a living model that can be modified by JavaScript, it provides an interface for JavaScript to modify the content, structure, or styling of the page.</p><p>Adding JavaScript programs will change the DOM, but will also not change the HTML source code.</p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> frontend </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mathematical Foundation of Data Science &amp; Engineering Exercises</title>
      <link href="/2020/03/17/mathematical-foundation-of-data-science-engineering-exercises/"/>
      <url>/2020/03/17/mathematical-foundation-of-data-science-engineering-exercises/</url>
      
        <content type="html"><![CDATA[<h1 id="数学基础第一次作业"><a href="#数学基础第一次作业" class="headerlink" title="数学基础第一次作业"></a>数学基础第一次作业</h1><p><img src="0.png" alt></p><p><strong>1</strong>. $\begin{pmatrix} -1 &amp; -4 &amp; 2\\ -5 &amp; 2 &amp; 1\\ \end{pmatrix}$</p><p><strong>2</strong>. $w^{cat}=\begin{bmatrix} 1 \\ 0\\0\\0 \end{bmatrix}$,$w^{dog}=\begin{bmatrix} 0\\1\\0\\0\end{bmatrix}$,$w^{parrot}=\begin{bmatrix} 0\\0\\1\\0\end{bmatrix}$,$w^{human}=\begin{bmatrix} 0\\0\\0\\1\end{bmatrix}$</p><p><strong>3</strong>. 计算IDF值：$idf_{I}=\frac{4}{3},idf_{you}=\frac{4}{3},idf_{know}=\frac{4}{4},idf_{that}=\frac{4}{2}$</p><p>计算TF值：$tf_{I}=\frac{4}{17},tf_{you}=\frac{3}{17},tf_{know}=\frac{7}{17},tf_{that}=\frac{3}{17}$</p><p>TF-IDF值：$tfidf_{I}=0.068,tfidf_{you}=0.051,tfidf_{know}=0,tfidf_{that}=0.122$</p><p><strong>4</strong>. 线性分类器的评分函数形式：$f(W; b; x_i) = Wx_i + b$</p><p>其中，xi 表示第i 张图像转换的大小为D × 1 的列向量。<br>评分函数的参数包括W 和b，W 是K × D 的矩阵，b 是K × 1 的列向量，K 表示类别的数量。</p><p>线性分类器主要有两部分组成：<br><strong>评分函数</strong>：原始图像数据到类别标签得分的映射;<br><strong>损失函数</strong>：用来量化预测标签的得分与真实标签之间的一致性。<br>该方法可以转化为一个最优化问题，在最优化过程中，将通过更新评分函数的参数来最小<br>化损失函数值。</p><p>引入两种简单的损失函数：</p><p>0-1 损失函数：<br>$L(Y,f(X)) =\begin{cases} 1 &amp; Y\neq f(X) \\ 0&amp; Y=f(X) \end{cases}$</p><p>平方损失函数：<br>$L(Y,f(X)) = (Y − f(X))^2$</p><p><strong>5</strong>. 为了方便损失函数计算，使用Softmax函数将一组$(-\infty,+\infty)$ 的得分$f$ 转换为一组$(0,1)$ 概率，并且这组概率的和为$1$。每张训练图像属于类别 $i$ 的概率得分用公式表示为：</p><p>$$p_{i}=\frac{e^{f_{i}}}{\sum_{j=1}^{K} e^{f_{j}}}$$</p><p>根据预测类别的概率得分，使用交叉熵函数作为损失函数，计算真实标签与预测标签之间的损失。<br>将标签 $y $ 转换为 $one − hot $ 向量$y$，例如真实标签为 4，则 $y = [0; 0; 0; 0; 1]$。<br>每张训练图像对应的交叉熵损失用公式表示为：</p><p>$$l=-\sum_{c=1}^{K} \boldsymbol{y}_{c} \log \left(\boldsymbol{p}_{c}\right)$$</p><p>其中, $K$ 是类别的数量；$y_c$ 表示当前图像的指示变量，如果预测标签与真实标签相同就<br>是$1$，否则为$0$；$p_c$ 是当前图像属于类别 $c$ 的概率得分。</p><p>显然每张图像只需要计算一个类别的概率得分和真实标签的交叉熵。因此第i 张图像的交<br>叉损失函数又可以表示为：</p><p>$$l_{i}=-\log \left(\frac{e^{f_{y_{i}}}}{\sum_{j=1}^{K} e^{f_{j}}}\right)=-f_{y_{i}}+\log \left(\sum_{j=1}^{K} e^{f_{j}}\right)$$</p><p>其中, $K$ 是类别的数量；$y_c$ 表示第$i$张图像的类别标签$ID$；$p_c$ 是当前图像属于类别 $c$ 的概率得分。</p><p>由概率得分公式可得，此时模型给各个数据的概率评分分别为：</p><p>$\begin{pmatrix} \frac{e^2}{e^2+e^8} \\ \frac{e^8}{e^2+e^8} \end{pmatrix}$，$\begin{pmatrix} \frac{e^1}{e^1+e^9} \\ \frac{e^9}{e^1+e^9} \end{pmatrix}$，$\begin{pmatrix} \frac{e^3}{e^3+e^2} \\ \frac{e^2}{e^3+e^2} \end{pmatrix}$，$\begin{pmatrix} \frac{e^1}{e^1+e^5} \\ \frac{e^5}{e^1+e^5} \end{pmatrix}$，$\begin{pmatrix} \frac{e^2}{e^2+e^0} \\ \frac{e^0}{e^2+e^0} \end{pmatrix}$</p><p>由交叉熵损失函数可得，各个数据的交叉熵损失分别为：</p><p>$-ln(\frac{e^8}{e^2+e^8})$,$-ln(\frac{e^9}{e^1+e^9})$,$-ln(\frac{e^2}{e^3+e^2})$,$-ln(\frac{e^1}{e^1+e^5})$,$-ln(\frac{e^2}{e^2+e^0})$</p><p><strong>6</strong>. <strong>结构风险(structural risk)</strong><br>在假设空间、损失函数以及训练数据集确定的情况下，结构风险定义为在经验风险上加上<br>表示模型复杂度的正则化项或罚项：</p><p>$$R_{s r m}(f)=\frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)+\lambda J(f)$$</p><p>其中$J_(f)$ 为模型的复杂度，是定义在假设空间F 上的泛函。模型f 越复杂，复杂度$J_(f)$ 就<br>越大；反之，模型f 越简单，复杂度$J_(f)$ 就越小。也就是说，复杂度表示了对复杂模型的<br>惩罚。$\lambda$ ≥ 0 是系数，用以权衡经验风险和模型复杂度。结构风险小需要经验风险与模型复<br>杂度同时小。结构风险小的模型往往对训练数据以及未知的测试数据都有较好的预测。</p><p><strong>结构风险最小化准则(structural risk minimization, SRM)</strong><br>结构风险最小化策略认为结构风险最小的模型是最优的模型。所以求最优模型，就是求解<br>最优化问题：</p><p>$$\min _{f \in \mathcal{F}} \frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)+\lambda J(f)$$</p><p>上述最优化问题一般也称为<strong>正则化(regularization)</strong>，正则化是结构风险最小化策略的实现。</p><p>在本题中，引入<strong>最小二乘问题</strong>的损失函数：</p><p>$$\min _{\boldsymbol{\theta}} \frac{1}{N}|\boldsymbol{y}-\boldsymbol{X} \boldsymbol{\theta}|^{2}$$</p><p>通过添加仅涉及$\theta$ 的正则项可以改善最小二乘问题的稳定性。<br>比如添加易于计算导数的$L_2$正则项：</p><p>$$\min _{\boldsymbol{\theta}} \frac{1}{N}|\boldsymbol{y}-\boldsymbol{X} \boldsymbol{\theta}|^{2}+\frac{\lambda}{2}|\boldsymbol{\theta}|_{2}^{2}$$</p><p>也可以添加$L_1$正则项得到参数更为稀疏的模型：</p><p>$$\min _{\boldsymbol{\theta}} \frac{1}{N}|\boldsymbol{y}-\boldsymbol{X} \boldsymbol{\theta}|^{2}+\lambda|\boldsymbol{\theta}|_{1}$$</p>]]></content>
      
      
      <categories>
          
          <category> exercises </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mathematical Foundation of Data Science &amp; Engineering </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在樱花漫天飞舞的时刻</title>
      <link href="/2020/03/15/zai-ying-hua-man-tian-fei-wu-de-shi-ke/"/>
      <url>/2020/03/15/zai-ying-hua-man-tian-fei-wu-de-shi-ke/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=440241194&auto=1&height=66">"></iframe></div><blockquote><p>桜の舞う空の彼方<br>在樱花满空飞舞的他方<br>目を閉じれば心の中<br>如果闭上眼睛就在心里</p></blockquote><p>在樱花漫天飞舞的时刻，你也一定能看得到</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>probability theory exercises</title>
      <link href="/2020/03/14/probability-theory-exercises/"/>
      <url>/2020/03/14/probability-theory-exercises/</url>
      
        <content type="html"><![CDATA[<h1 id="概率论第一次作业"><a href="#概率论第一次作业" class="headerlink" title="概率论第一次作业"></a>概率论第一次作业</h1><p>textbook:”Introduction to Probability, 2E”<br>Dimitri P.Bertsekas,John N.Tsitsiklis<br>郑忠国 童行伟 译  人民邮电出版社</p><p>第一次作业：</p><ol><li><p>第一章习题5（p48）</p><p>解：A = “学生是天才”，B=”学生喜欢巧克力”</p><p>$P( A \cup B) = P(A) + P(B) - P(A \cap B) = 0.6+0.7-0.4=0.9$</p><p>$P(A^C \cap B^C) = 1-P(A \cup B)=1-0.9=0.1$</p></li></ol><ol start="2"><li><p>第一章习题7（p48）</p><p>解：骰子有四个面，分别为1，2，3，4，连续抛若干次，直到第一次出现偶数面为止。</p><p>如果第n次抛出了偶数面，则结果序列为$(a_{1},a_{2},a_{3},…,a_{n})$ ，其中，$a_{1},a_{2},a_{3},…a_{n-1}\in\lbrace1,3\rbrace$ ,</p><p>$a_{n}\in\lbrace2,4\rbrace$ </p><p>如果始终没有抛出偶数面，则结果序列为$(a_{1},a_{2},a_{3},…)$ ，其中每个元素属于$\lbrace1,3\rbrace$</p><p>样本空间即包含以上两种类型中的所有可能的情况</p></li></ol><ol start="3"><li><p>第一章习题9（p48）</p><p>解：</p><p>a)</p><p>$P(A)=P(A \cap \Omega) = P(A \cap (\cup^{n}_{i=1}S_{i}))=P((A \cap S_{1}) \cup (A \cap S_{2})… \cup(A \cap S_{n})) = \sum^{n}_{i=1}P(A \cap S_{i})$</p><p>b)</p><p>$\because P(A)= \sum^{n}_{i=1}P(A \cap S_{i})$</p><p>$\because P(B \cup C \cup (B^C \cap C^C)) - P(B \cap C)= \Omega$</p><p>$ \therefore P(A)=P(A \cap B)+P(A \cap C)+P(A \cap B^{C} \cap C^{C})-P(A \cap B \cap C)$</p></li></ol><ol start="4"><li><p>第一章习题10（p48）</p><p>证明：</p><p>$ P((A \cap B^{C}) \cup (A^{C} \cap B)) $</p><p>$= P(A \cap B^C)+P(A^C \cap B)-P(A\cap B^{C}\cap A^{C}\cap B)$</p><p>$= P(A\cap (\Omega-B))+P((\Omega-A)\cap B)$</p><p>$=P(A)+P(B)-2P(A\cap B)$</p></li></ol><ol start="5"><li><p>思考题：你能否证明快速排序的平均复杂度是$O(n\log n)$？</p><p>证明：</p><p>$T(n)=2T(n/2)+n$ ，由Master Theorem可得其平均复杂度为 $O(n\log n)$</p></li></ol><ol start="6"><li><p>思考题：一副扑克牌（54张）随机发给3个人，每人18张。三个人中有人拿到一副同花顺（花色相同，数字连续，序列是：2-10, J, Q, K, A）的可能性有多少？</p><p>解：</p><p>如果题目中的同花顺，为传统意义上的同花顺，即连续五张及以上的同花，那么必须手动考虑很多情况，在这过程中还会出现很多重复情况，列出来计算很复杂；如果使用计算机，用蒙特卡洛方法破解，样本空间太大也不行。</p><p>由于题目对同花顺的定义不明确，如果同花顺是花色相同的序列2-10,J,Q,K,A，那么用容斥原理可解。</p><p>$P(A\cup B \cup C)=P(A)+P(B)+P(C)-P(A \cap B)-P(A\cap C)-P(B\cap C)+P(A\cap B\cap C)$</p><p>$=3\times {4\choose 1}{41 \choose 5}/{54 \choose 18}-3\times {4\choose 1}{3\choose 1} {28 \choose 5} {23 \choose 5}/{54 \choose 18}{36 \choose 18}+{4\choose 1} {3\choose 1} {2\choose 1}{15 \choose 5}{10 \choose 5}{5 \choose 5}/{54 \choose 18}{36 \choose 18}{18 \choose 18}$</p></li></ol><p>第二次作业：</p><ol><li><p>第一章习题14（p50）</p><p>解：</p><p>a.$\frac{1}{6}$</p><p>b. there are six kinds of situations，two of them are pairs, so the probability is $\frac{1}{3}$</p><p>c.$\frac{11}{36}$</p><p>d.$\frac{1}{3}$</p></li></ol><ol start="2"><li><p>第一章习题16（p50）</p><p>解：</p><p>$\frac{1}{2}$</p></li><li><p>第一章习题18（p50）</p><p>证明：using the definition of conditional probability :</p><p>$P(A\cap B|B)= P(A\cap B\cap B)/P(B)=P(A\cap B)/P(B)=P(A|B)$</p></li></ol><ol start="4"><li><p>第一章习题20（p51）</p><p>a. 解：</p><p>1.$p^2_w+2p_w(1-p_w)p_w=3p^2_w-2p^3_w$</p><p>2.$p^2_d\cdot p_w$</p><p>3.$p_w\cdot p_d+p_w\cdot (1-p_d)\cdot p_w+(1-p_w)\cdot p_w\cdot p_w$</p><p>b. 证明：</p><p>When $p_w$is lower than 0.5,  but $p_d$ is greater than 0.5, the player can choose the defensive mode to increase the winning probability.</p><p>For example: $p_w=0.45,p_d=0.9$</p><p>the winning probability will be $p_w\cdot p_d+p_w\cdot (1-p_d)\cdot p_w+(1-p_w)p_w^2=0.45\cdot 0.9+0.45\cdot 0.1\cdot 0.45+(1-0.45)\cdot 0.45^2$</p><p>$=0.405+0.02025+0.55\cdot0.2025=0.537$</p></li><li><p>第一章习题24（p51）</p><p>解：There are four possible outcomes:</p><p>   A and B are to be released, and guard says B        probability = $\frac{1}{3}$</p><p>   A and C are to be released, and guard says C        probability = $\frac{1}{3}$</p><p>   B and C are to be released, and guard says B        probability = $\frac{1}{6}$</p><p>   B and C are to be released, and guard says C        probability = $\frac{1}{6}$</p><p>   P(A is to be released|guard says B)=<br>$$<br>\frac{\frac{1}{3}}{\frac{1}{3}+\frac{1}{6}}=\frac{2}{3}<br>$$<br>   Similarly, P(A is to be released|guard says C)=$\frac{2}{3}$</p><p>   Thus, the probability that A is to be released will not change.</p></li><li><p>第一章习题25（p51）</p><p>解：</p><p>Let:</p><p>$$A=\{X&lt;\underline{m}), \quad B=\{\underline{m}&lt;X&lt;\bar{m}), \quad C=\{\bar{m}&lt;X)$$</p><p>A,B,C, refer to different cases.</p><p>$\underline{m}$ refers to the smaller amount, $\bar{m}$ refers to the larger amount.</p><p>$\mathbf{P}(W)$ refers to the possibility to have the larger amount.</p><p>$$\begin{array}{l}<br>\mathbf{P}(W | A)=\frac{1}{2}(\mathbf{P}(W | \bar{A})+\mathbf{P}(W | \underline{A}))=\frac{1}{2}(1+0)=\frac{1}{2} \\\<br>\mathbf{P}(W | B)=\frac{1}{2}(\mathbf{P}(W | \bar{B})+\mathbf{P}(W | \underline{B}))=\frac{1}{2}(1+1)=1 \\\<br>\mathbf{P}(W | C)=\frac{1}{2}(\mathbf{P}(W | \bar{C})+\mathbf{P}(W | \underline{C}))=\frac{1}{2}(0+1)=\frac{1}{2}<br>\end{array}$$</p><p>$$\begin{aligned}<br>\mathbf{P}(W) &amp;=\mathbf{P}(A) \mathbf{P}(W | A)+\mathbf{P}(B) \mathbf{P}(W | B)+\mathbf{P}(C) \mathbf{P}(W | C) \\\<br>&amp;=\frac{1}{2}(\mathbf{P}(A)+\mathbf{P}(B)+\mathbf{P}(C))+\frac{1}{2} \mathbf{P}(B) \\\<br>&amp;=\frac{1}{2}+\frac{1}{2} \mathbf{P}(B)<br>\end{aligned}$$</p><p>$\mathbf{P}(B)&gt;0$ as assumed. Thus, it follows that $\mathbf{P}(W)&gt;1/2$</p></li></ol><ol start="7"><li><p>第一章习题26（p52）</p><p>解：<br>$$<br>\mathbf{P}(A | B)=\frac{\mathbf{P}(A \cap B)}{\mathbf{P}(B)}=\frac{\mathbf{P}(A) \mathbf{P}(B | A)}{\mathbf{P}(B)}<br>$$<br> $\mathbf{P}(B)=1-q$ , as all the crows are black(hypothesis).</p><p> $\mathbf{P}(A)=p .$ </p><p> $\mathbf{P}(B | A)=1-q=\mathbf{P}(B),$ as the probability of observing a (black) crow is not affected by the truth of our hypothesis. </p><p>Therefore,  $\mathbf{P}(A | B)=\mathbf{P}(A)=p$. </p><p>Thus, the new evidence, while compatible with the hypothesis “all cows are white,” does not change our beliefs about its truth.<br>(b)<br>$$<br>\mathbf{P}(A | C)=\frac{\mathbf{P}(A \cap C)}{\mathbf{P}(C)}=\frac{\mathbf{P}(A) \mathbf{P}(C | A)}{\mathbf{P}(C)}<br>$$<br>Given the event $A$, a cow is observed with probability $q$, and it must be white. Thus, $\mathbf{P}(C | A)=q .$ Given the event $A^{c},$ a cow is observed with probability $q,$ and it is white with probability $1 / 2 .$ Thus, $\mathbf{P}\left(C | A^{c}\right)=q / 2 .$ Using the total probability theorem,<br>$$<br>\mathbf{P}(C)=\mathbf{P}(A) \mathbf{P}(C | A)+\mathbf{P}\left(A^{c}\right) \mathbf{P}\left(C | A^{c}\right)=p q+(1-p) \frac{q}{2}<br>$$<br>Hence,<br>$$<br>\mathbf{P}(A | C)=\frac{p q}{p q+(1-p) \frac{q}{2}}=\frac{2 p}{1+p}&gt;p<br>$$</p></li><li><p>第一章习题31（p53）</p><p>解：</p><p>(a) $A$ is the event that 0 is transmitted, the probability of correct transmission is :<br>$$<br>\mathbf{P}(A)\left(1-\epsilon_{0}\right)+(1-\mathbf{P}(A))\left(1-\epsilon_{1}\right)=p\left(1-\epsilon_{0}\right)+(1-p)\left(1-\epsilon_{1}\right)<br>$$<br>(b) The probability that 1011 is corrected transmitted is :<br>$$<br>\left(1-\epsilon_{0}\right)\left(1-\epsilon_{1}\right)^{3}<br>$$<br>(c) The string received must be 100, 000, 010, 001 to be correctly identified as 0.</p><p>While transmitting 000, the probability that received as 000 is $\left(1-\epsilon_{0}\right)^{3},$</p><p>as $001,010,$ $100$ $\epsilon_{0}\left(1-\epsilon_{0}\right)^{2}$ each.</p><p>Thus, the probability of correct transmission is<br>$$<br>3 \epsilon_{0}\left(1-\epsilon_{0}\right)^{2}+\left(1-\epsilon_{0}\right)^{3}<br>$$<br>(d) To improve the correctness of the transmission of 0, it has to be<br>$$<br>3 \epsilon_{0}\left(1-\epsilon_{0}\right)^{2}+\left(1-\epsilon_{0}\right)^{3}&gt;\left(1-\epsilon_{0}\right)<br>$$<br>or<br>$$<br>\left(1-\epsilon_{0}\right)\left(1+2 \epsilon_{0}\right)&gt;1<br>$$<br>which is equivalent to $0&lt;\epsilon_{0}&lt;1 / 2$<br>(e) Using Bayes’ rule, we have<br>$$<br>\mathbf{P}(0 | 101)=\frac{\mathbf{P}(0) \mathbf{P}(101 | 0)}{\mathbf{P}(0) \mathbf{P}(101 | 0)+\mathbf{P}(1) \mathbf{P}(101 | 1)}<br>$$<br>the probabilities needed in the equation are listed as follow.<br>$$<br>\mathbf{P}(0)=p, \quad \mathbf{P}(1)=1-p, \quad \mathbf{P}(101 | 0)=\epsilon_{0}^{2}\left(1-\epsilon_{0}\right), \quad \mathbf{P}(101 | 1)=\epsilon_{1}\left(1-\epsilon_{1}\right)^{2}<br>$$</p></li><li><p>第一章习题33（p54）</p><p>解：</p><p>As long as $\mathbf{P}$ (heads) $&gt;0$ and $\mathbf{P}(\text { tails })&gt;0$ , flipping the coin for twice, the probabilities of heads-tails, and tails-heads, are the same. So repeat the process of flipping twice until the decision has been made. Assuming $A_k$ is the probability that the decision has made in the $k^{th}$ round, then the conclusion is that<br>$$<br>P(\text { opera })=\sum_{k=1}^{\infty} P\left(\text { opera } | A_{k}\right) P\left(A_{k}\right)=\sum_{k=1}^{\infty} \frac{1}{2} P\left(A_{k}\right)=\frac{1}{2}<br>$$<br>$P\left(\text { opera } | A_{k}\right) $  is $\frac{1}{2}$ , and $\sum_{k=0}^{\infty} \mathbf{P}\left(A_{k}\right)=1$ , which are easy to infer.</p></li></ol><ol start="10"><li><p>第一章习题35（p54）</p><p>解：</p><p>$A_i$ is exactly the event that $i$ components are optional.<br>$$<br>\sum_{i=k}^{n} \mathbf{P}\left(A_{i}\right)=\sum_{i=k}^{n} p(i)<br>$$<br>where $p(i)$ are the binomial probabilities. Thus, the probability of an operational system is<br>$$<br>\sum_{i=k}^{n}\left(\begin{array}{l}<br>n \<br>i<br>\end{array}\right) p^{i}(1-p)^{n-i}<br>$$</p></li><li><p>(o) 思考题：请证明条件概率是一个概率律（满足概率三条公理）？</p><p>证明：</p><p>$(\mathrm{a}) 0 \leq P(E | F) \leq 1$<br>(b) $P(S | F)=1$<br>(c) $\overrightarrow{\mathrm{E} }_i(i=1,2, \cdots)$ 为互不相容的事件序列，则<br>$$<br>P\left(\bigcup_{i=1}^{\infty} E_{i} | F\right)=\sum_{i=1}^{\infty} P\left(E_{i} | F\right)<br>$$</p></li><li><p>(o) 思考题：请证明：$$P(\bigcap_{i=1}^nA_i)=P(A_1)P(A_2|A_1)P(A_3|A_1\cap A_2)\ldots P(A_n|\bigcap_{i=1}^{n-1}A_i)$$</p><p>证明：</p><p>$P(A_n|\bigcap_{i=1}^{n-1}A_i)\cdot P(\bigcap_{i=1}^{n-1}A_i)=P(\bigcap_{i=1}^{n}A_i)$</p><p>所以 $P(A_1)P(A_2|A_1)P(A_3|A_1\cap A_2)\ldots P(A_n|\bigcap_{i=1}^{n-1}A_i)\\\\=P(A_2\cap A_1)P(A_3|A_1\cap A_2)\ldots P(A_n|\bigcap_{i=1}^{n-1}A_i)\\\\=P(A_3\cap A_1\cap A_2)\ldots P(A_n|\bigcap_{i=1}^{n-1}A_i)\\\\\vdots\\\\=P(\bigcap_{i=1}^nA_i)$</p></li></ol><ol start="15"><li><p>(*) 思考题：两个相互独立的事件，是否一定条件独立？如果是，请证明；如果不是，请给出示例。<br>事件A是两次掷骰子的和为奇数，事件B是第一次掷骰子为奇数，条件C是掷两次骰子，第二次掷骰子为奇数。<br>$P(A)=\frac{1}{2}$，$P(B)=\frac{1}{2}$  $P(AB)=\frac{1}{4}$<br>$P(A|C)=\frac{1}{2}$，$P(B|C)=\frac{1}{2}$  $P(AB|C)=0$</p></li><li><p>(*) 思考题：两个在某个条件$C$下条件独立的事件，是否一定相互独立？如果是，请证明；如果不是，请给出示例。<br>有一枚硬币正面的概率为 99%，另一枚反面的概率为 99%，随机拿出一枚投掷两次，事件 A 为第一次为正面，事件 B 为第二次为正面，事件 C 为拿出的是第一枚硬币。P(B) = 0.5 而 P(B|A) = 0.9802，说明 A 和 B 不独立，但如果 C 已经发生，即已知了拿出的是第一枚硬币，那么 A 和 B 就（条件）独立了</p></li><li><p>(*) 思考题：两两独立，是否包含独立？为什么？<br>两两独立的事件不一定相互独立。比如事件A为第一次掷骰子为奇数，B为第二次掷骰子为奇数，C为两次掷骰子的和为奇数。而互相独立一定两两独立。</p></li></ol><ol start="18"><li><p>(*) 思考题：以下结论是否成立：$P(A_1\cap A_2\cap A_3)=P(A_1)P(A_2)P(A_3)$不包含独立？为什么？<br>设实验是掷两个均匀的骰子<br>事件A为第一次扔得1，2或3，事件B为第一次扔得3，4，5，事件C为两次扔得的点数之和为9<br>可得事件两两之间不独立</p></li><li><p>思考题：你能否用计算机近似计算：一副扑克牌（54张）随机发给3个人，每人18张。三个人中有人拿到一副同花顺（花色相同，数字连续，序列是：2-10, J, Q, K, A）的可能性有多少？</p><p>解：</p><p>At the first time, l thought the permutation and combination method in this problem was too complex, and the previous answer has definitely double-counted a lot of cases. </p><p>Besides, according to my experience, the possibility to get a straight flush is very low, so l think the previous answer must be greater than the truth.</p><p>Actually, there do have a lot of double-counted cases, but it turns out that there are also a lot of cases omitted. And l did think of solving it with Monte Carlo method, but the sample space is as large as ${ {54}\choose {18} } { {36}\choose {18} }/6=1.4\times 10^{23}$, l thought it would at least take up $1\%$ of sample space for Monte Carlo to get the valid answer. However, surprisingly, only $10^6$ random cases can approximately converge. l had run the program 10 times, and got the average, the answer is about 0.202148. l was very surprised and amazed. It was definitely an unforgettable experience.</p><p>answers: 0.19982 0.20529 0.20412 0.20205 0.20068 0.20005 0.203 0.20067 0.20297 0.20283</p><p>average: 0.202148</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> tqdm <span class="token keyword">import</span> tqdm<span class="token keyword">def</span> <span class="token function">validate</span><span class="token punctuation">(</span>card<span class="token punctuation">)</span><span class="token punctuation">:</span>    count<span class="token operator">=</span><span class="token number">1</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>card<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> card<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>card<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span>            count <span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">if</span> count<span class="token operator">==</span><span class="token number">5</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            count<span class="token operator">=</span><span class="token number">1</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token comment" spellcheck="true">#validate the existance of straight_flush</span><span class="token keyword">def</span> <span class="token function">judge</span><span class="token punctuation">(</span>card<span class="token punctuation">)</span><span class="token punctuation">:</span>    diamond<span class="token punctuation">,</span> spade<span class="token punctuation">,</span> club<span class="token punctuation">,</span> heart <span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> card<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">>=</span><span class="token number">52</span><span class="token punctuation">:</span>            <span class="token keyword">continue</span>        <span class="token keyword">if</span> card<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">4</span> <span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            diamond<span class="token punctuation">.</span>append<span class="token punctuation">(</span>card<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">//</span><span class="token number">4</span><span class="token punctuation">)</span>        <span class="token keyword">elif</span> card<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">4</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>            spade<span class="token punctuation">.</span>append<span class="token punctuation">(</span>card<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">//</span><span class="token number">4</span><span class="token punctuation">)</span>        <span class="token keyword">elif</span> card<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">4</span><span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">:</span>            club<span class="token punctuation">.</span>append<span class="token punctuation">(</span>card<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">//</span><span class="token number">4</span><span class="token punctuation">)</span>        <span class="token keyword">elif</span> card<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">4</span><span class="token operator">==</span><span class="token number">3</span><span class="token punctuation">:</span>            heart<span class="token punctuation">.</span>append<span class="token punctuation">(</span>card<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">//</span><span class="token number">4</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#classification</span>    diamond<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>    spade<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>    club<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>    heart<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> validate<span class="token punctuation">(</span>diamond<span class="token punctuation">)</span> <span class="token operator">or</span> validate<span class="token punctuation">(</span>spade<span class="token punctuation">)</span> <span class="token operator">or</span> validate<span class="token punctuation">(</span>club<span class="token punctuation">)</span> <span class="token operator">or</span> validate<span class="token punctuation">(</span>heart<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">1</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python">card<span class="token operator">=</span>np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">54</span><span class="token punctuation">)</span><span class="token punctuation">)</span>test_times<span class="token operator">=</span><span class="token number">100000</span>straight_flush<span class="token operator">=</span><span class="token number">0</span><span class="token keyword">for</span> i <span class="token keyword">in</span> tqdm<span class="token punctuation">(</span>range<span class="token punctuation">(</span>test_times<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span>card<span class="token punctuation">)</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        start <span class="token operator">=</span> j<span class="token operator">*</span><span class="token number">18</span>        <span class="token keyword">if</span> judge<span class="token punctuation">(</span>card<span class="token punctuation">[</span>start<span class="token punctuation">:</span>start<span class="token operator">+</span><span class="token number">18</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>            straight_flush<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">break</span>     <span class="token comment" spellcheck="true">#deal again</span>rate<span class="token operator">=</span>straight_flush<span class="token operator">/</span>test_times<span class="token keyword">print</span><span class="token punctuation">(</span>rate<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> exercises </category>
          
      </categories>
      
      
        <tags>
            
            <tag> probability theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写在开学之前</title>
      <link href="/2020/03/03/xie-zai-kai-xue-zhi-qian/"/>
      <url>/2020/03/03/xie-zai-kai-xue-zhi-qian/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28815250&auto=0&height=66"></iframe></div><blockquote><p>悔不该耽于逸乐，至有今日。</p></blockquote><blockquote><p>直到看见平凡才是唯一的答案。</p></blockquote><p>漫长的寒假就快要结束了，开学在即。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于开源的一点个人理解</title>
      <link href="/2020/03/01/guan-yu-kai-yuan-de-yi-dian-ge-ren-li-jie/"/>
      <url>/2020/03/01/guan-yu-kai-yuan-de-yi-dian-ge-ren-li-jie/</url>
      
        <content type="html"><![CDATA[<p>忽然想到要聊一聊开源，就写下这篇随笔，作为记录。<br>在上大学之前，我知道开源，但是这个词汇在我的生活里出现得还不多。进入大二以来，我逐渐更加了解开源，<br>我把我对开源软件的一些思考和理解，做一些总结。</p><h1 id="开源软件是什么"><a href="#开源软件是什么" class="headerlink" title="开源软件是什么"></a>开源软件是什么</h1><blockquote><p>开源软件（OSS）是与源代码一起分发的软件，可以由用户读取或修改。普遍开源软件应符合自由分发、源代码必须包含在程序中、任何人都必须能够修改源代码、可以重新分发源代码的修改版本等标准。</p></blockquote><p>开源软件到底是什么，是互不相识的程序员通过互联网，协作开发的免费软件吗？<br>那如果是免费软件，开发者的收益在哪里？只是做善事吗？</p><h1 id="开源软件的收益在哪里"><a href="#开源软件的收益在哪里" class="headerlink" title="开源软件的收益在哪里"></a>开源软件的收益在哪里</h1><p>开发软件所需要的工程量往往是很大的，一个人没有足够的时间精力完成，而如果这个软件一般是程序员本人需要用的，或者是其他人需要用的，<br>这样，开发者将自己开发的软件，开源到社区，号召其他程序员帮助自己开发软件。<br>开发者开源的第一个收益，就是借助社区的力量，完成自己的作品，造福自己造福他人。<br>那有人问为什么不用已经发行的商业软件呢？首先商业软件不一定是免费的，其次商业软件的功能以及维护未必能达到用户的需求。<br>对于开发者来说，第二个收益就是在开源协作开发中磨练自己的能力，证明自己的实力。</p><h1 id="开源软件战胜闭源软件"><a href="#开源软件战胜闭源软件" class="headerlink" title="开源软件战胜闭源软件"></a>开源软件战胜闭源软件</h1><p>软件公司开发商业软件，卖给企业和个人使用，并提供技术支持，这样的“软件卖钱”时代（模式），我认为已经过去了，或者说慢慢过去了。<br>在蓝海海域，有开源的地方，闭源的商业软件生长不出来。一定程度上说，计算机技术太复杂了，所以蓝海挺多的，很多琐碎的需求，难以提供一揽子服务，也助长了开源的环境。<br>在红海海域，商业软件比较成熟的地方，我认为开源会逐渐战胜闭源。有的闭源软件工程量太大，功能也比较完善，已经广泛运用，比如windows操作系统，matlab，我觉得不太可能被开源打败。在越来越多的领域，出现了功能强大的开源软件，足以替代商业软件。</p><h1 id="开源和开源的竞争"><a href="#开源和开源的竞争" class="headerlink" title="开源和开源的竞争"></a>开源和开源的竞争</h1><p>随着越来越多的企业加入开源，有一种说法是，现在已经不是开源和闭源的竞争，而是开源和开源的竞争。这样竞争的收益是什么呢？<br>我个人的理解是：<br>1，开源软件竞争的是，技术标准的领导权。<br>2，开源软件竞争的是，平台的生态，用户规模和数据。<br>这也符合当下互联网经济的特点，有流量就有利润。为了迅速占领市场，让更多开发者和普通用户拥抱自家的软件（平台），企业不仅开放平台，甚至还让利。<br>可以预见未来开源和开源的竞争还会更加激烈。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
